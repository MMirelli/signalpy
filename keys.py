'''
This module contains classes and functions keeping the state of 
X3DH key pairs and the logic for their serialization as data structs
containing all or some of the keys, as needed.
'''

from cryptography.hazmat.primitives.asymmetric \
    import ec
from cryptography.hazmat.backends \
    import openssl
from cryptography.hazmat.primitives.hashes \
    import SHA256
from cryptography.hazmat.primitives.ciphers.aead \
    import AESGCM
from cryptography.hazmat.primitives.kdf.hkdf \
    import HKDF
from cryptography.hazmat.primitives.serialization \
    import Encoding, PublicFormat

from cryptography.exceptions import InvalidSignature

import shared
import pickle
import time
import random
import os

#================ metaclasses ============================ 
class Singleton(type):
    # https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

#============= utils ================================

#------------- logging -------------------------------
def indent(s):
    '''
    Adds to all '\,','\[','\]' the indentation string '\n\t'
    '''
    lineSep = '\n\t'
    repls = { i:i+lineSep for i in  ['\,','\[']}
    for r in repls:
        s = s.replace(r, repls[r][1:])
    s = s.replace('\]', lineSep+']')
    return s


def indent_nested(s):
    '''
    Adds to all '\,','\[','\]' the indentation string '\t'
    '''
    s = s.replace('\n\t', '\n\t\t')
    return s


#------------- crypto helpers ---------------------------------
class SaltHelper(metaclass=Singleton):
    '''
    This class offers the methods used for salt management. 
    
    Using random, it is *not* based on cryptographically secure 
    pseudo-random generator. However, this should not put at risk
    the security of the system as a whole, as long as the outputs
    are used as salts.
    '''
    def __init__(self, logger):
        self.SEED_FILE = 'seed0.txt'
        self.logger = logger
        self.next_seed = None
        
    def generate_seed(self):
        '''
        Stores a time-based seed in the current directory.
        '''
        self.logger.info('Generating new seed')
        seed0 = time.time_ns()
        with open(self.SEED_FILE, 'w+') as f:
            f.write(str(seed0))
        
    def read_initial_seed(self):
        with open(self.SEED_FILE, 'r') as f:
            rst = f.readline()
        self.logger.info(f'Seed read: {rst}')
        return rst

    def update_seed(self):
        '''
        If next_seed is set, returns it; otherwise, it
        updates the random seed using a pseudo random 
        number generated by randint.
        '''
        ns = self.read_initial_seed()
        if self.next_seed is None:
            new_seed = ns
        else:
            n = len(ns)
            range_start = 10 ** (n-1)
            range_end = (10**n) - 1
            new_seed = random.randint(range_start, range_end)
            
        self.next_seed = new_seed

    def seed_salt_generator(self):
        self.update_seed()
        random.seed(self.next_seed)

        
    def new_salt(self):
        self.seed_salt_generator()
        rst = ''
        for i in range(16):
            cur_rand = random.randint(0,255)
            rst += chr(cur_rand)
        return rst.encode('utf-8')


    
class KeyHelper(metaclass=Singleton):
    '''
    This class contains all the used crypto tools and performs
    the main crypto operations.
    '''

    def __init__(self, logger):

        # eXtended 3ple Diffie Hellman crypto
        self.X3DH_EXC_ALG = ec.ECDH()
        self.X3DH_EC = ec.SECP256K1()
        self.X3DH_SIGN_ALG = ec.ECDSA

        # Double Ratchet crypto
        self.DR_ENC_ALG = AESGCM
        self.DR_ENC_KEY_LEN = 32 # 32 B = 256 bits

        # shared crypto
        self.BE = openssl.backend
        self.HASH = SHA256()

        self.logger = logger
        
        self.sh = SaltHelper(self.logger)

        
    def gen_key(self):
        generated = ec.generate_private_key(
            curve=self.X3DH_EC, backend=self.BE
        )
        self.logger.info(f'Private key generated: {generated}')
        return generated

    
    def sign(self, signing_k, signed_pk):
        self.logger.info(f'Signing pk {signed_pk} with k {signing_k}')
        return EllipticCurveSignedPublicKey(
            self.logger,
            pk=signed_pk,
            signature=signing_k.sign(
                self.serialize_pk(signed_pk),
                self.X3DH_SIGN_ALG(self.HASH)
            )
        )


    def exchange(self, private_key, public_key):
        return private_key.exchange(self.X3DH_EXC_ALG, public_key)
    
    
    def verify(self, signing_k, signature, original_data):
        try:
            signing_k.verify(
                signature,
                original_data,
                self.X3DH_SIGN_ALG(self.HASH)
            )
            self.logger.info(f'Verification of signature {signature} successful')
        except InvalidSignature as e :
            self.logger.info(f'Verification of signature {signature} failed\n{e}')


    def serialize_pk(self, pk):
        '''
        Serializes the public key of the key pair. 

        '''
        if pk is not None:
            self.logger.info(f'Serializing {pk}')
            return pk.public_bytes(
                Encoding.X962,
                PublicFormat.CompressedPoint
            )

        
    def deserialize_pk(self, spk):
        '''
        Deserializes the public key of the key pair
        '''
        if spk is not None:
            self.logger.info(f'Deserializing {spk}')
            return ec.EllipticCurvePublicKey.\
                from_encoded_point(self.X3DH_EC, spk)


    def hkdf(self, k, j=None):
        cur_salt = self.sh.new_salt()
        if j is None:
            # asymmetric racheting
            info = b'root'
        else:
            # symmetric racheting
            info = b'message'
        
        hkdf = HKDF( algorithm=self.HASH,   
                     # it outputs 2 256-byte keys
                     length=self.DR_ENC_KEY_LEN * 2,
                     salt=cur_salt,
                     info=info,
                     backend=self.BE
        )
        
        rst = hkdf.derive(k)
        
        return rst[:self.DR_ENC_KEY_LEN], rst[self.DR_ENC_KEY_LEN:]
        

    def encrypt(self, enc_key, msg):
        aesgcm = self.DR_ENC_ALG(enc_key)
        nonce = os.urandom(12)
        ct = aesgcm.encrypt(nonce=nonce,
                            data=msg.encode('utf-8'),
                            associated_data=None)
        return ct, nonce


    def decrypt(self, dec_key, ct, nonce):
        aesgcm = self.DR_ENC_ALG(dec_key)
        return aesgcm.decrypt(nonce=nonce,
                              data=ct,
                              associated_data=None)



#================ Signal Primitives ===================

#---------------- Signed Pre Key -----------------------
class EllipticCurveSignedPublicKey():
    '''
    Data structure used for storing preks (pre-signed 
    mid-term public keys). 
    '''
    
    def __init__(self, logger, pk=None, signature=None, serialized_key=None):
        # mask this variable in order to uniform with the EllipticCurvePublicKey API
        self.logger = logger
        self.kh = KeyHelper(self.logger)

        if serialized_key is None:
            self.__public_key = pk
            self.signature = signature
        else:
            self.__public_key, self.signature = \
                self.deserialize(serialized_key)

            
    def public_key(self):
        return self.__public_key

    
    def __str__(self):
        return indent('EllipticCurveSignedPublicKey=\['+\
            f'public_key={self.kh.serialize_pk(self.public_key())}\,'+\
            f'signature={self.signature}\]')

    
    def serialize(self):
        return { 'pk': self.kh.serialize_pk(self.public_key()),
                 'sign': self.signature
        }

    
    def deserialize(self, sk):
        return self.kh.deserialize_pk(sk['pk']), sk['sign']

    
#---------------- X3DH Node Info -----------------------    
class NodeInfo():
    '''
    Used for storing own X3DH key pairs and Node id (mobile number). 
    It also offers a public keys serializing feature.
    '''

    def __init__(self, tel_numb, logger):
        
        self.logger = logger

        self.kh = KeyHelper(self.logger)
        
        # telephone number
        self.id = tel_numb
        # X3DH
        # long-term identity private key 
        self.ik = self.kh.gen_key()
        # mid-term signed private prekey
        self.prek = self.kh.gen_key()

        # signing prepk
        self.prepk = self.kh.sign(
            self.ik,
            self.prek.public_key()
        )

        # ephemeral private key
        self.ek = self.kh.gen_key()

        self.logger.info('Keys generated:\n'+str(self))


    def __str__(self):
        return indent('NodeKeys=\['+\
        f'Id: {self.id}\,'+\
        f'Identity pubkey: {self.kh.serialize_pk(self.ik.public_key())}\,'+\
        f'Signed pre-pubkey: {indent_nested(str(self.prepk))}\,'+\
        f'Ephemeral pubkey: {self.kh.serialize_pk(self.ek.public_key())}\]'
        )

    
    def serialize(self, except_for=[]):
        '''
        Serializes all fields of NodeInfo except for the ones in 
        except_for list.
        '''
        data = {
            'id': self.id,
            'ipk': self.kh.serialize_pk(self.ik.public_key()),
            'prepk': self.prepk.serialize(),
            'epk': self.kh.serialize_pk(self.ek.public_key())
        }

        for ef in except_for:
            if ef in data:
                data.pop(ef)

        return pickle.dumps(data)

    
    def compute_initiator_ms(self, other_party_pub):
        '''
        Computes the master secret for the initiator.
        '''
        
        self.logger.info('Computing master-secret for the initiator side')
        # X3DH
        other_party_pub.verify_prepk()
        ik_prepk = self.kh.exchange(self.ik,
                                    other_party_pub.prepk.public_key())
        ek_ipk = self.kh.exchange(self.ek,
                                  other_party_pub.ipk)
        ek_prepk = self.kh.exchange(self.ek,
                                    other_party_pub.prepk.public_key())
        
        master_secret = ik_prepk + ek_ipk + ek_prepk

        self.logger.info(f'Master secret computed: {master_secret}')
        return master_secret

        
    def compute_responder_ms(self, other_party_pub):
        '''
        Computes the master secret for the responder.
        '''
        self.logger.info('Computing master-secret for the responder side')
        prek_ipk = self.kh.exchange(self.prek,
                                    other_party_pub.ipk)
        ik_epk = self.kh.exchange(self.ik,
                                  other_party_pub.epk)
        prek_epk = self.kh.exchange(self.prek,
                                    other_party_pub.epk)

        master_secret = prek_ipk + ik_epk + prek_epk
        self.logger.info(f'Master secret computed: {master_secret}')
        return master_secret


    def compute_new_key(self, keys):
        '''
        Computes a new ephemeral key.
        '''
        log_info = lambda key_type: \
            self.logger.info(f'New {key_type} key computed: {self}')
        
        for k in keys:
            if k == 'ek':
                log_info('ephemeral')
                self.ek = self.kh.gen_key()
                

#---------------- X3DH public info serializer ---------------------
class NodePublicInfo():
    '''
    Used for storing X3DH public keys and id (mobile number) of 
    the user we are communicating to (other_party). 
    It also offers a public keys deserializing feature.
    '''
    
    def __init__(self, serialized_info, logger):

        self.logger = logger
        self.kh = KeyHelper(self.logger)

        # X3DH
        self.id, self.ipk, self.prepk, self.epk = [None] * 4
        self.union(serialized_info)

        
    def union(self, serialized_info):
        self.id, self.ipk, self.prepk, self.epk = \
            self.deserialize(serialized_info)
        return self

    
    def serialize(self, except_for=[]):
        '''
        Serializes all fields of NodeInfo except for the ones in 
        except_for list.
        '''
        data = {
            'id': self.id,
            'ipk': self.kh.serialize_pk(self.ipk),
            'prepk': self.prepk.serialize(),
            'epk': self.kh.serialize_pk(self.epk)
        }

        for ef in except_for:
            if ef in data:
                data.pop(ef)

        return pickle.dumps(data)

    
    def deserialize(self, spks):
        dic = pickle.loads(spks)
        rst = [self.id, self.ipk, self.prepk, self.epk]
        for key in dic:
            if key == 'id':
                rst[0] = dic[key]
            elif key == 'ipk':
                rst[1] = self.kh.deserialize_pk(dic[key])
            elif key == 'prepk':
                rst[2] = EllipticCurveSignedPublicKey(
                    self.logger,
                    serialized_key=dic[key]
                )
            elif key == 'epk':
                rst[3] = self.kh.deserialize_pk(dic[key])
        return tuple(rst)

    
    def verify_prepk(self):
        signed_data = self.kh.serialize_pk(self.prepk.public_key())
        self.kh.verify(
            self.ipk,
            self.prepk.signature,
            signed_data
        )
    
    def __str__(self):
        return indent('NodePublicInfo=\['+\
                f'Id: {self.id}\,'+\
                f'Identity pubkey: {self.kh.serialize_pk(self.ipk)}\,'+\
                f'Signed pre-pubkey: {indent_nested(str(self.prepk))}\,'+\
                f'Ephemeral pubkey: {self.kh.serialize_pk(self.epk)}\]')


#---------------- DR public info serializer ---------------------
class MsgHolder():
    '''
    Transfers the i-th message, the i-th public ratchet 
    key and the j-th symmetric ratchet index used for 
    deriving the message key, mk_{ij}.
    '''
    
    def __init__(self, holder, logger):

        self.logger = logger
        self.kh = KeyHelper(self.logger)

        if type(holder) is dict:
            self.msg = holder['msg']
            self.nonce = holder['nonce']
            self.rchpk = holder['rchpk']
            self.j = holder['j']
        else:
            self.msg, self.nonce, self.rchpk, self.j = \
                self.deserialize(holder)

            
    def __str__(self):
        return indent('MessageHolder=\['+\
                f'msg: {self.msg}\,'+\
                f'nonce: {self.nonce}\,'+\
                f'rchpk: {self.kh.serialize_pk(self.rchpk)}\,'+\
                f'j: {self.j}\]')

        
    def serialize(self):
        '''
        Serializes all fields of MsgHolder except for the ones in 
        except_for list.
        '''
        data = {
            'msg': self.msg,
            'nonce': self.nonce,
            'rchpk': self.kh.serialize_pk(self.rchpk),
            'j': self.j
        }
        
        return pickle.dumps(data)

    
    def deserialize(self, msg_holder_ser):
        dic = pickle.loads(msg_holder_ser)
        rst = [None] * 4
        for key in dic:
            if key == 'msg':
                rst[0] = dic[key]
            elif key == 'nonce':
                rst[1] = dic[key]
            elif key == 'rchpk':
                rst[2] = self.kh.deserialize_pk(dic[key])
            elif key == 'j':
                rst[3] = int(dic[key])
        return tuple(rst)

        
#---------------- DR state ---------------------
class RatchetKeys():
    
    def __init__(self, master_secret, logger):
        self.logger = logger
        self.kh = KeyHelper(self.logger)

        # my asymmetric ratchet
        self.rchk = None
        # other party public ratchet key
        self.op_rchpk = None

        # symmetric ratchet
        # root key
        self.rk = master_secret
        # number of symmetric ratchet
        self.j = 0
        # chaining key
        self.ck = 'None'
        # symmetric message encryption/decryption key
        self.mk = 'None'
        # number of other party's symmetric ratchet
        self.op_j = 0

        
    def __str__(self):
        my_rchk = None
        if self.rchk is not None:
            my_rchk = self.kh.serialize_pk(self.rchk.public_key())
            
        return indent('RatchetKeys=\['+\
            f'My rchpk: {my_rchk}\,'+\
            f'Other party\'s rchpk: {self.kh.serialize_pk(self.op_rchpk)}\,'+\
            f'Root key: {self.rk}\,'+\
            f'Symmetric ratchet number: {self.j}\,'+\
            f'Other party\'s symmetric ratchet number: {self.op_j}\,'+\
            f'Chaining key: {self.ck}\,'
            f'Message key: {self.mk}\]'
        )

    
    def is_equal_to_op_rchpk(self, msg_rchpk):
        ser_op_rchpk = self.kh.serialize_pk(self.op_rchpk) 
        ser_msg_rchpk = self.kh.serialize_pk(msg_rchpk)
        self.logger.info(f'{ser_op_rchpk} \n {ser_msg_rchpk}')
        return ser_op_rchpk == ser_msg_rchpk
        

    
    def _capitalize_first(self, string):
        return string[0].upper()+string[1:]

    
    def log_info(self, key_type):
        self.logger.info(f'{self._capitalize_first(key_type)}'+\
                         f' key updated:\n{self}')

        
    def update_key(self, key_type, k):
        if key_type == 'op_rchpk':
            self.op_rchpk = k
            self.log_info('other party ratchet public')
        if key_type == 'rk':
            self.rk = k
            self.log_info('root')
        if key_type == 'j':
            self.j = k
            self.log_info('symmetric ratchet number of')

    
    def compute_new_key(self, key_type):
        if key_type == 'rchk':
            self.rchk = self.kh.gen_key()                
            self.log_info('ratchet')


    def _log_sym_ratchet(self, ratchet_type):
        self.logger.info(f'{self._capitalize_first(ratchet_type)} '+\
                         f'ratchet:\n{self}')
            
    
    def new_asym_rchs(self, my_info, other_party_pub):
        '''
        Computes the current ratchet shared secret.
        '''
        cur_k, cur_pk = None, None
        if self.op_rchpk is None:
            # this is the case when rk = ms and the current user
            # is the initiator
            cur_k = self.rchk
            cur_pk = other_party_pub.prepk.public_key()
        else:
            # either this is the responder in the case rk = ms or
            # we are at a further step of the asymmetric ratchet
            cur_pk = self.op_rchpk

            if self.rchk is None:
                # this is the responder in the case rk = ms
                cur_k = my_info.prek
            else:
                # further step of asymmetric ratchet
                cur_k = self.rchk
        cur_rk = self.rk + self.kh.exchange(cur_k, cur_pk)

        self.rk, self.ck = self.kh.hkdf(cur_rk)
        self._log_sym_ratchet('asymmetric')


    def encrypt(self, msg):
        self.ck, self.mk = self.kh.hkdf(self.ck)
        self.j += 1
        self._log_sym_ratchet('symmetric')
        return self.kh.encrypt(self.mk, msg)


    def decrypt(self, ct, nonce):
        self.ck, self.mk = self.kh.hkdf(self.ck)
        self._log_sym_ratchet('symmetric')
        return self.kh.decrypt(self.mk, ct, nonce)

        
#---------------- testing ----------------------------
def set_up():
    alice_logger = shared.complete_logger('Alice')
    return NodeInfo('+358 111 222 333', alice_logger),\
        NodeInfo('+358 222 333 111', alice_logger), alice_logger # bob's

salt = None
def fake_salt():
    global salt
    if salt is None:
        ttp_logger = shared.complete_logger('TTP')
        sh = SaltHelper(ttp_logger)
        salt = sh.new_salt()
        
    print(salt)
#fake_salt()
#fake_salt()


def prepare_message(ms_a, msg, na, bpub, archk):

    archk.compute_new_key('rchk')
    ark = archk.new_asym_rchs(na, bpub)
    salt = fake_salt()

    ct, nonce = archk.encrypt(msg)
    
    return {
        'msg': ct,
        'nonce' : nonce,
        'rchpk' : archk.rchk.public_key(),
        'j' : 0
    }, salt


def test_compute_ms(na, nb, alice_logger):

    serialized_b = nb.serialize(except_for=['epk'])
    bpub = NodePublicInfo(serialized_b, alice_logger)
    ms_a = na.compute_initiator_ms(
        bpub
    )
    
    serialized_a = na.serialize(except_for=['prepk'])
    apub = NodePublicInfo(serialized_a, alice_logger)
    ms_b = nb.compute_responder_ms(
        apub
    )

    print (ms_a == ms_b)
    return ms_a, apub, ms_b, bpub


def test_e2ee():
    na, nb, al = set_up()

    ms_a, apub, ms_b, bpub = test_compute_ms(na,nb,al)
    archk = RatchetKeys(ms_a, al)
    msg, salt = prepare_message(ms_a, 'hello', na, bpub, archk)
    
    mh = MsgHolder(msg, al)
    mh_ser = mh.serialize()

    mh_des = MsgHolder(mh_ser, al)
   
    brchk = RatchetKeys(ms_b, al)
    brchk.update_key('op_rchpk', archk.rchk.public_key())

    brk = brchk.new_asym_rchs(nb, apub)
    pt = brchk.decrypt(mh_des.msg, mh_des.nonce)
    print(pt)


#test_e2ee()
#
#    msg = 
#    na.rchk.public_key()



#    publicInfo.verify_prepk()
#    print('prepk successfully verified')

def test_salt():
    ttp_logger = shared.complete_logger('TTP')
    sh = SaltHelper(ttp_logger)
    print(sh.fake_salt())
    print(sh.fake_salt())
    #sh.generate_seed()
    # for i in range(10):
    #     ns = sh.new_salt()
    #     print(ns)

#test_salt()

def test_partial():
    ni, al_logger = set_up()
    serialized_data0 = ni.serialize(['ipk', 'prepk', 'epk'])
    serialized_data1 = ni.serialize(['id', 'epk'])
    
    publicInfo = NodePublicInfo(serialized_data0, al_logger)
    print(publicInfo.union(serialized_data1))


    serialized_data1 = ni.serialize(['prepk'])
    
    publicInfo = NodePublicInfo(serialized_data1, al_logger)
    print(publicInfo)

    
#test_complete()
#test_partial()

#print('The end')
